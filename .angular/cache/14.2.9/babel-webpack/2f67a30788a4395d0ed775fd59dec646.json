{"ast":null,"code":"var glMatrix = require(\"gl-matrix\"),\n    vec3 = glMatrix.vec3;\n/**\r\n * Constructs a Pointable object.\r\n *\r\n * An uninitialized pointable is considered invalid.\r\n * Get valid Pointable objects from a Frame or a Hand object.\r\n *\r\n * @class Pointable\r\n * @memberof Leap\r\n * @classdesc\r\n * The Pointable class reports the physical characteristics of a detected\r\n * finger or tool.\r\n *\r\n * Both fingers and tools are classified as Pointable objects. Use the\r\n * Pointable.tool property to determine whether a Pointable object represents a\r\n * tool or finger. The Leap classifies a detected entity as a tool when it is\r\n * thinner, straighter, and longer than a typical finger.\r\n *\r\n * Note that Pointable objects can be invalid, which means that they do not\r\n * contain valid tracking data and do not correspond to a physical entity.\r\n * Invalid Pointable objects can be the result of asking for a Pointable object\r\n * using an ID from an earlier frame when no Pointable objects with that ID\r\n * exist in the current frame. A Pointable object created from the Pointable\r\n * constructor is also invalid. Test for validity with the Pointable.valid\r\n * property.\r\n */\n\n\nvar Pointable = module.exports = function (data) {\n  /**\r\n   * Indicates whether this is a valid Pointable object.\r\n   *\r\n   * @member valid\r\n   * @type {Boolean}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n  this.valid = true;\n  /**\r\n   * A unique ID assigned to this Pointable object, whose value remains the\r\n   * same across consecutive frames while the tracked finger or tool remains\r\n   * visible. If tracking is lost (for example, when a finger is occluded by\r\n   * another finger or when it is withdrawn from the Leap field of view), the\r\n   * Leap may assign a new ID when it detects the entity in a future frame.\r\n   *\r\n   * Use the ID value with the pointable() functions defined for the\r\n   * {@link Frame} and {@link Frame.Hand} classes to find this\r\n   * Pointable object in future frames.\r\n   *\r\n   * @member id\r\n   * @type {String}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.id = data.id;\n  this.handId = data.handId;\n  /**\r\n   * The estimated length of the finger or tool in millimeters.\r\n   *\r\n   * The reported length is the visible length of the finger or tool from the\r\n   * hand to tip. If the length isn't known, then a value of 0 is returned.\r\n   *\r\n   * @member length\r\n   * @type {number}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.length = data.length;\n  /**\r\n   * Whether or not the Pointable is believed to be a tool.\r\n   * Tools are generally longer, thinner, and straighter than fingers.\r\n   *\r\n   * If tool is false, then this Pointable must be a finger.\r\n   *\r\n   * @member tool\r\n   * @type {Boolean}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.tool = data.tool;\n  /**\r\n   * The estimated width of the tool in millimeters.\r\n   *\r\n   * The reported width is the average width of the visible portion of the\r\n   * tool from the hand to the tip. If the width isn't known,\r\n   * then a value of 0 is returned.\r\n   *\r\n   * Pointable objects representing fingers do not have a width property.\r\n   *\r\n   * @member width\r\n   * @type {number}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.width = data.width;\n  /**\r\n   * The direction in which this finger or tool is pointing.\r\n   *\r\n   * The direction is expressed as a unit vector pointing in the same\r\n   * direction as the tip.\r\n   *\r\n   * ![Finger](images/Leap_Finger_Model.png)\r\n   * @member direction\r\n   * @type {number[]}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.direction = data.direction;\n  /**\r\n   * The tip position in millimeters from the Leap origin.\r\n   * Stabilized\r\n   *\r\n   * @member stabilizedTipPosition\r\n   * @type {number[]}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.stabilizedTipPosition = data.stabilizedTipPosition;\n  /**\r\n   * The tip position in millimeters from the Leap origin.\r\n   *\r\n   * @member tipPosition\r\n   * @type {number[]}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.tipPosition = data.tipPosition;\n  /**\r\n   * The rate of change of the tip position in millimeters/second.\r\n   *\r\n   * @member tipVelocity\r\n   * @type {number[]}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.tipVelocity = data.tipVelocity;\n  /**\r\n   * The current touch zone of this Pointable object.\r\n   *\r\n   * The Leap Motion software computes the touch zone based on a floating touch\r\n   * plane that adapts to the user's finger movement and hand posture. The Leap\r\n   * Motion software interprets purposeful movements toward this plane as potential touch\r\n   * points. When a Pointable moves close to the adaptive touch plane, it enters the\r\n   * \"hovering\" zone. When a Pointable reaches or passes through the plane, it enters\r\n   * the \"touching\" zone.\r\n   *\r\n   * The possible states include:\r\n   *\r\n   * * \"none\" -- The Pointable is outside the hovering zone.\r\n   * * \"hovering\" -- The Pointable is close to, but not touching the touch plane.\r\n   * * \"touching\" -- The Pointable has penetrated the touch plane.\r\n   *\r\n   * The touchDistance value provides a normalized indication of the distance to\r\n   * the touch plane when the Pointable is in the hovering or touching zones.\r\n   *\r\n   * @member touchZone\r\n   * @type {String}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.touchZone = data.touchZone;\n  /**\r\n   * A value proportional to the distance between this Pointable object and the\r\n   * adaptive touch plane.\r\n   *\r\n   * ![Touch Distance](images/Leap_Touch_Plane.png)\r\n   *\r\n   * The touch distance is a value in the range [-1, 1]. The value 1.0 indicates the\r\n   * Pointable is at the far edge of the hovering zone. The value 0 indicates the\r\n   * Pointable is just entering the touching zone. A value of -1.0 indicates the\r\n   * Pointable is firmly within the touching zone. Values in between are\r\n   * proportional to the distance from the plane. Thus, the touchDistance of 0.5\r\n   * indicates that the Pointable is halfway into the hovering zone.\r\n   *\r\n   * You can use the touchDistance value to modulate visual feedback given to the\r\n   * user as their fingers close in on a touch target, such as a button.\r\n   *\r\n   * @member touchDistance\r\n   * @type {number}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.touchDistance = data.touchDistance;\n  /**\r\n   * How long the pointable has been visible in seconds.\r\n   *\r\n   * @member timeVisible\r\n   * @type {number}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.timeVisible = data.timeVisible;\n};\n/**\r\n * A string containing a brief, human readable description of the Pointable\r\n * object.\r\n *\r\n * @method toString\r\n * @memberof Leap.Pointable.prototype\r\n * @returns {String} A description of the Pointable object as a string.\r\n */\n\n\nPointable.prototype.toString = function () {\n  return \"Pointable [ id:\" + this.id + \" \" + this.length + \"mmx | width:\" + this.width + \"mm | direction:\" + this.direction + ' ]';\n};\n/**\r\n * Returns the hand which the pointable is attached to.\r\n */\n\n\nPointable.prototype.hand = function () {\n  return this.frame.hand(this.handId);\n};\n/**\r\n * An invalid Pointable object.\r\n *\r\n * You can use this Pointable instance in comparisons testing\r\n * whether a given Pointable instance is valid or invalid. (You can also use the\r\n * Pointable.valid property.)\r\n\r\n * @static\r\n * @type {Leap.Pointable}\r\n * @name Invalid\r\n * @memberof Leap.Pointable\r\n */\n\n\nPointable.Invalid = {\n  valid: false\n};","map":null,"metadata":{},"sourceType":"script"}