{"ast":null,"code":"var Pointable = require(\"./pointable\"),\n    Bone = require('./bone'),\n    glMatrix = require(\"gl-matrix\"),\n    mat3 = glMatrix.mat3,\n    vec3 = glMatrix.vec3;\n/**\r\n * Constructs a Hand object.\r\n *\r\n * An uninitialized hand is considered invalid.\r\n * Get valid Hand objects from a Frame object.\r\n * @class Hand\r\n * @memberof Leap\r\n * @classdesc\r\n * The Hand class reports the physical characteristics of a detected hand.\r\n *\r\n * Hand tracking data includes a palm position and velocity; vectors for\r\n * the palm normal and direction to the fingers; properties of a sphere fit\r\n * to the hand; and lists of the attached fingers.\r\n *\r\n * Note that Hand objects can be invalid, which means that they do not contain\r\n * valid tracking data and do not correspond to a physical entity. Invalid Hand\r\n * objects can be the result of asking for a Hand object using an ID from an\r\n * earlier frame when no Hand objects with that ID exist in the current frame.\r\n * A Hand object created from the Hand constructor is also invalid.\r\n * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.\r\n */\n\n\nvar Hand = module.exports = function (data) {\n  /**\r\n   * A unique ID assigned to this Hand object, whose value remains the same\r\n   * across consecutive frames while the tracked hand remains visible. If\r\n   * tracking is lost (for example, when a hand is occluded by another hand\r\n   * or when it is withdrawn from or reaches the edge of the Leap field of view),\r\n   * the Leap may assign a new ID when it detects the hand in a future frame.\r\n   *\r\n   * Use the ID value with the {@link Frame.hand}() function to find this\r\n   * Hand object in future frames.\r\n   *\r\n   * @member id\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {String}\r\n   */\n  this.id = data.id;\n  /**\r\n   * The center position of the palm in millimeters from the Leap origin.\r\n   * @member palmPosition\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number[]}\r\n   */\n\n  this.palmPosition = data.palmPosition;\n  /**\r\n   * The direction from the palm position toward the fingers.\r\n   *\r\n   * The direction is expressed as a unit vector pointing in the same\r\n   * direction as the directed line from the palm position to the fingers.\r\n   *\r\n   * @member direction\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number[]}\r\n   */\n\n  this.direction = data.direction;\n  /**\r\n   * The rate of change of the palm position in millimeters/second.\r\n   *\r\n   * @member palmVeclocity\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number[]}\r\n   */\n\n  this.palmVelocity = data.palmVelocity;\n  /**\r\n   * The normal vector to the palm. If your hand is flat, this vector will\r\n   * point downward, or \"out\" of the front surface of your palm.\r\n   *\r\n   * ![Palm Vectors](images/Leap_Palm_Vectors.png)\r\n   *\r\n   * The direction is expressed as a unit vector pointing in the same\r\n   * direction as the palm normal (that is, a vector orthogonal to the palm).\r\n   * @member palmNormal\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number[]}\r\n   */\n\n  this.palmNormal = data.palmNormal;\n  /**\r\n   * The center of a sphere fit to the curvature of this hand.\r\n   *\r\n   * This sphere is placed roughly as if the hand were holding a ball.\r\n   *\r\n   * ![Hand Ball](images/Leap_Hand_Ball.png)\r\n   * @member sphereCenter\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number[]}\r\n   */\n\n  this.sphereCenter = data.sphereCenter;\n  /**\r\n   * The radius of a sphere fit to the curvature of this hand, in millimeters.\r\n   *\r\n   * This sphere is placed roughly as if the hand were holding a ball. Thus the\r\n   * size of the sphere decreases as the fingers are curled into a fist.\r\n   *\r\n   * @member sphereRadius\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number}\r\n   */\n\n  this.sphereRadius = data.sphereRadius;\n  /**\r\n   * Reports whether this is a valid Hand object.\r\n   *\r\n   * @member valid\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {boolean}\r\n   */\n\n  this.valid = true;\n  /**\r\n   * The list of Pointable objects (fingers) detected in this frame\r\n   * that are associated with this hand, given in arbitrary order. The list\r\n   * can be empty if no fingers or tools associated with this hand are detected.\r\n   *\r\n   * Use the {@link Pointable} tool property to determine\r\n   * whether or not an item in the list represents a tool or finger.\r\n   * You can also get only the fingers using the Hand.fingers[] list.\r\n   *\r\n   * @member pointables[]\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {Leap.Pointable[]}\r\n   */\n\n  this.pointables = [];\n  /**\r\n   * The list of fingers detected in this frame that are attached to\r\n   * this hand, given in arbitrary order.\r\n   *\r\n   * The list can be empty if no fingers attached to this hand are detected.\r\n   *\r\n   * @member fingers[]\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {Leap.Pointable[]}\r\n   */\n\n  this.fingers = [];\n\n  if (data.armBasis) {\n    this.arm = new Bone(this, {\n      type: 4,\n      width: data.armWidth,\n      prevJoint: data.elbow,\n      nextJoint: data.wrist,\n      basis: data.armBasis\n    });\n  } else {\n    this.arm = null;\n  }\n\n  this._translation = data.t;\n\n  function flattenDeep(arr) {\n    return Array.isArray(arr) ? arr.reduce(function (a, b) {\n      return a.concat(flattenDeep(b));\n    }, []) : [arr];\n  }\n\n  this._rotation = flattenDeep(data.r);\n  this._scaleFactor = data.s;\n  /**\r\n   * Time the hand has been visible in seconds.\r\n   *\r\n   * @member timeVisible\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number}\r\n   */\n\n  this.timeVisible = data.timeVisible;\n  /**\r\n   * The palm position with stabalization\r\n   * @member stabilizedPalmPosition\r\n   * @memberof Leap.Hand.prototype\r\n   * @type {number[]}\r\n   */\n\n  this.stabilizedPalmPosition = data.stabilizedPalmPosition;\n  /**\r\n  * Reports whether this is a left or a right hand.\r\n  *\r\n  * @member type\r\n  * @type {String}\r\n  * @memberof Leap.Hand.prototype\r\n  */\n\n  this.type = data.type;\n  this.grabStrength = data.grabStrength;\n  this.pinchStrength = data.pinchStrength;\n  this.confidence = data.confidence;\n};\n/**\r\n * The finger with the specified ID attached to this hand.\r\n *\r\n * Use this function to retrieve a Pointable object representing a finger\r\n * attached to this hand using an ID value obtained from a previous frame.\r\n * This function always returns a Pointable object, but if no finger\r\n * with the specified ID is present, an invalid Pointable object is returned.\r\n *\r\n * Note that the ID values assigned to fingers persist across frames, but only\r\n * until tracking of a particular finger is lost. If tracking of a finger is\r\n * lost and subsequently regained, the new Finger object representing that\r\n * finger may have a different ID than that representing the finger in an\r\n * earlier frame.\r\n *\r\n * @method finger\r\n * @memberof Leap.Hand.prototype\r\n * @param {String} id The ID value of a finger from a previous frame.\r\n * @returns {Leap.Pointable} The Finger object with\r\n * the matching ID if one exists for this hand in this frame; otherwise, an\r\n * invalid Finger object is returned.\r\n */\n\n\nHand.prototype.finger = function (id) {\n  var finger = this.frame.finger(id);\n  return finger && finger.handId == this.id ? finger : Pointable.Invalid;\n};\n/**\r\n * The angle of rotation around the rotation axis derived from the change in\r\n * orientation of this hand, and any associated fingers, between the\r\n * current frame and the specified frame.\r\n *\r\n * The returned angle is expressed in radians measured clockwise around the\r\n * rotation axis (using the right-hand rule) between the start and end frames.\r\n * The value is always between 0 and pi radians (0 and 180 degrees).\r\n *\r\n * If a corresponding Hand object is not found in sinceFrame, or if either\r\n * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.\r\n *\r\n * @method rotationAngle\r\n * @memberof Leap.Hand.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\r\n * @param {numnber[]} [axis] The axis to measure rotation around.\r\n * @returns {number} A positive value representing the heuristically determined\r\n * rotational change of the hand between the current frame and that specified in\r\n * the sinceFrame parameter.\r\n */\n\n\nHand.prototype.rotationAngle = function (sinceFrame, axis) {\n  if (!this.valid || !sinceFrame.valid) return 0.0;\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return 0.0;\n  var rot = this.rotationMatrix(sinceFrame);\n  var cs = (rot[0] + rot[4] + rot[8] - 1.0) * 0.5;\n  var angle = Math.acos(cs);\n  angle = isNaN(angle) ? 0.0 : angle;\n\n  if (axis !== undefined) {\n    var rotAxis = this.rotationAxis(sinceFrame);\n    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));\n  }\n\n  return angle;\n};\n/**\r\n * The axis of rotation derived from the change in orientation of this hand, and\r\n * any associated fingers, between the current frame and the specified frame.\r\n *\r\n * The returned direction vector is normalized.\r\n *\r\n * If a corresponding Hand object is not found in sinceFrame, or if either\r\n * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.\r\n *\r\n * @method rotationAxis\r\n * @memberof Leap.Hand.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\r\n * @returns {number[]} A normalized direction Vector representing the axis of the heuristically determined\r\n * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nHand.prototype.rotationAxis = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return vec3.create();\n  return vec3.normalize(vec3.create(), [this._rotation[7] - sinceHand._rotation[5], this._rotation[2] - sinceHand._rotation[6], this._rotation[3] - sinceHand._rotation[1]]);\n};\n/**\r\n * The transform matrix expressing the rotation derived from the change in\r\n * orientation of this hand, and any associated fingers, between\r\n * the current frame and the specified frame.\r\n *\r\n * If a corresponding Hand object is not found in sinceFrame, or if either\r\n * this frame or sinceFrame are invalid Frame objects, then this method returns\r\n * an identity matrix.\r\n *\r\n * @method rotationMatrix\r\n * @memberof Leap.Hand.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\r\n * @returns {number[]} A transformation Matrix containing the heuristically determined\r\n * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nHand.prototype.rotationMatrix = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return mat3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return mat3.create();\n  var transpose = mat3.transpose(mat3.create(), this._rotation);\n  var m = mat3.multiply(mat3.create(), sinceHand._rotation, transpose);\n  return m;\n};\n/**\r\n * The scale factor derived from the hand's motion between the current frame and the specified frame.\r\n *\r\n * The scale factor is always positive. A value of 1.0 indicates no scaling took place.\r\n * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.\r\n *\r\n * The Leap derives scaling from the relative inward or outward motion of a hand\r\n * and its associated fingers (independent of translation and rotation).\r\n *\r\n * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame\r\n * are invalid Frame objects, then this method returns 1.0.\r\n *\r\n * @method scaleFactor\r\n * @memberof Leap.Hand.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.\r\n * @returns {number} A positive value representing the heuristically determined\r\n * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nHand.prototype.scaleFactor = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return 1.0;\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return 1.0;\n  return Math.exp(this._scaleFactor - sinceHand._scaleFactor);\n};\n/**\r\n * The change of position of this hand between the current frame and the specified frame\r\n *\r\n * The returned translation vector provides the magnitude and direction of the\r\n * movement in millimeters.\r\n *\r\n * If a corresponding Hand object is not found in sinceFrame, or if either this frame or\r\n * sinceFrame are invalid Frame objects, then this method returns a zero vector.\r\n *\r\n * @method translation\r\n * @memberof Leap.Hand.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.\r\n * @returns {number[]} A Vector representing the heuristically determined change in hand\r\n * position between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nHand.prototype.translation = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  var sinceHand = sinceFrame.hand(this.id);\n  if (!sinceHand.valid) return vec3.create();\n  return [this._translation[0] - sinceHand._translation[0], this._translation[1] - sinceHand._translation[1], this._translation[2] - sinceHand._translation[2]];\n};\n/**\r\n * A string containing a brief, human readable description of the Hand object.\r\n * @method toString\r\n * @memberof Leap.Hand.prototype\r\n * @returns {String} A description of the Hand as a string.\r\n */\n\n\nHand.prototype.toString = function () {\n  return \"Hand (\" + this.type + \") [ id: \" + this.id + \" | palm velocity:\" + this.palmVelocity + \" | sphere center:\" + this.sphereCenter + \" ] \";\n};\n/**\r\n * The pitch angle in radians.\r\n *\r\n * Pitch is the angle between the negative z-axis and the projection of\r\n * the vector onto the y-z plane. In other words, pitch represents rotation\r\n * around the x-axis.\r\n * If the vector points upward, the returned angle is between 0 and pi radians\r\n * (180 degrees); if it points downward, the angle is between 0 and -pi radians.\r\n *\r\n * @method pitch\r\n * @memberof Leap.Hand.prototype\r\n * @returns {number} The angle of this vector above or below the horizon (x-z plane).\r\n *\r\n */\n\n\nHand.prototype.pitch = function () {\n  return Math.atan2(this.direction[1], -this.direction[2]);\n};\n/**\r\n *  The yaw angle in radians.\r\n *\r\n * Yaw is the angle between the negative z-axis and the projection of\r\n * the vector onto the x-z plane. In other words, yaw represents rotation\r\n * around the y-axis. If the vector points to the right of the negative z-axis,\r\n * then the returned angle is between 0 and pi radians (180 degrees);\r\n * if it points to the left, the angle is between 0 and -pi radians.\r\n *\r\n * @method yaw\r\n * @memberof Leap.Hand.prototype\r\n * @returns {number} The angle of this vector to the right or left of the y-axis.\r\n *\r\n */\n\n\nHand.prototype.yaw = function () {\n  return Math.atan2(this.direction[0], -this.direction[2]);\n};\n/**\r\n *  The roll angle in radians.\r\n *\r\n * Roll is the angle between the y-axis and the projection of\r\n * the vector onto the x-y plane. In other words, roll represents rotation\r\n * around the z-axis. If the vector points to the left of the y-axis,\r\n * then the returned angle is between 0 and pi radians (180 degrees);\r\n * if it points to the right, the angle is between 0 and -pi radians.\r\n *\r\n * @method roll\r\n * @memberof Leap.Hand.prototype\r\n * @returns {number} The angle of this vector to the right or left of the y-axis.\r\n *\r\n */\n\n\nHand.prototype.roll = function () {\n  return Math.atan2(this.palmNormal[0], -this.palmNormal[1]);\n};\n/**\r\n * An invalid Hand object.\r\n *\r\n * You can use an invalid Hand object in comparisons testing\r\n * whether a given Hand instance is valid or invalid. (You can also use the\r\n * Hand valid property.)\r\n *\r\n * @static\r\n * @type {Leap.Hand}\r\n * @name Invalid\r\n * @memberof Leap.Hand\r\n */\n\n\nHand.Invalid = {\n  valid: false,\n  fingers: [],\n  pointables: [],\n  left: false,\n  pointable: function () {\n    return Pointable.Invalid;\n  },\n  finger: function () {\n    return Pointable.Invalid;\n  },\n  toString: function () {\n    return \"invalid frame\";\n  },\n  dump: function () {\n    return this.toString();\n  },\n  rotationAngle: function () {\n    return 0.0;\n  },\n  rotationMatrix: function () {\n    return mat3.create();\n  },\n  rotationAxis: function () {\n    return vec3.create();\n  },\n  scaleFactor: function () {\n    return 1.0;\n  },\n  translation: function () {\n    return vec3.create();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}