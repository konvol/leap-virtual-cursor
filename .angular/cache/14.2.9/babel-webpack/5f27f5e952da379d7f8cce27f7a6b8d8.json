{"ast":null,"code":"var Pipeline = module.exports = function (controller) {\n  this.steps = [];\n  this.controller = controller;\n};\n\nPipeline.prototype.addStep = function (step) {\n  this.steps.push(step);\n};\n\nPipeline.prototype.run = function (frame) {\n  var stepsLength = this.steps.length;\n\n  for (var i = 0; i != stepsLength; i++) {\n    if (!frame) break;\n    frame = this.steps[i](frame);\n  }\n\n  return frame;\n};\n\nPipeline.prototype.removeStep = function (step) {\n  var index = this.steps.indexOf(step);\n  if (index === -1) throw \"Step not found in pipeline\";\n  this.steps.splice(index, 1);\n};\n/*\r\n * Wraps a plugin callback method in method which can be run inside the pipeline.\r\n * This wrapper method loops the callback over objects within the frame as is appropriate,\r\n * calling the callback for each in turn.\r\n *\r\n * @method createStepFunction\r\n * @memberOf Leap.Controller.prototype\r\n * @param {Controller} The controller on which the callback is called.\r\n * @param {String} type What frame object the callback is run for and receives.\r\n *       Can be one of 'frame', 'finger', 'hand', 'pointable'\r\n * @param {function} callback The method which will be run inside the pipeline loop.  Receives one argument, such as a hand.\r\n * @private\r\n */\n\n\nPipeline.prototype.addWrappedStep = function (type, callback) {\n  var controller = this.controller,\n      step = function (frame) {\n    var dependencies, i, len;\n    dependencies = type == 'frame' ? [frame] : frame[type + 's'] || [];\n\n    for (i = 0, len = dependencies.length; i < len; i++) {\n      callback.call(controller, dependencies[i]);\n    }\n\n    return frame;\n  };\n\n  this.addStep(step);\n  return step;\n};","map":null,"metadata":{},"sourceType":"script"}