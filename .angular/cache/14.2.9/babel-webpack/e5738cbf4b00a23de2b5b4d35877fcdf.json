{"ast":null,"code":"var Pointable = require('./pointable'),\n    glMatrix = require(\"gl-matrix\"),\n    vec3 = glMatrix.vec3,\n    mat3 = glMatrix.mat3,\n    mat4 = glMatrix.mat4;\n\nvar Bone = module.exports = function (finger, data) {\n  this.finger = finger;\n  this._center = null, this._matrix = null;\n  /**\r\n  * An integer code for the name of this bone.\r\n  *\r\n  * * 0 -- metacarpal\r\n  * * 1 -- proximal\r\n  * * 2 -- medial\r\n  * * 3 -- distal\r\n  * * 4 -- arm\r\n  *\r\n  * @member type\r\n  * @type {number}\r\n  * @memberof Leap.Bone.prototype\r\n  */\n\n  this.type = data.type;\n  /**\r\n   * The position of the previous, or base joint of the bone closer to the wrist.\r\n   * @type {vector3}\r\n   */\n\n  this.prevJoint = data.prevJoint;\n  /**\r\n   * The position of the next joint, or the end of the bone closer to the finger tip.\r\n   * @type {vector3}\r\n   */\n\n  this.nextJoint = data.nextJoint;\n  /**\r\n   * The estimated width of the pointable in millimeters.\r\n   *\r\n   * The reported width is the average width of the visible portion of the\r\n   * pointable from the hand to the tip. If the width isn't known,\r\n   * then a value of 0 is returned.\r\n   *\r\n   * Bone objects representing fingers do not have a width property.\r\n   *\r\n   * @member width\r\n   * @type {number}\r\n   * @memberof Leap.Pointable.prototype\r\n   */\n\n  this.width = data.width;\n  var displacement = new Array(3);\n  vec3.sub(displacement, data.nextJoint, data.prevJoint);\n  this.length = vec3.length(displacement);\n  /**\r\n   *\r\n   * These fully-specify the orientation of the bone.\r\n   * See examples/threejs-bones.html for more info\r\n   * Three vec3s:\r\n   *  x (red): The rotation axis of the finger, pointing outwards.  (In general, away from the thumb )\r\n   *  y (green): The \"up\" vector, orienting the top of the finger\r\n   *  z (blue): The roll axis of the bone.\r\n   *\r\n   *  Most up vectors will be pointing the same direction, except for the thumb, which is more rightwards.\r\n   *\r\n   *  The thumb has one fewer bones than the fingers, but there are the same number of joints & joint-bases provided\r\n   *  the first two appear in the same position, but only the second (proximal) rotates.\r\n   *\r\n   *  Normalized.\r\n   */\n\n  this.basis = data.basis;\n};\n\nBone.prototype.left = function () {\n  if (this._left) return this._left;\n  this._left = mat3.determinant(this.basis[0].concat(this.basis[1]).concat(this.basis[2])) < 0;\n  return this._left;\n};\n/**\r\n * The Affine transformation matrix describing the orientation of the bone, in global Leap-space.\r\n * It contains a 3x3 rotation matrix (in the \"top left\"), and center coordinates in the fourth column.\r\n *\r\n * Unlike the basis, the right and left hands have the same coordinate system.\r\n *\r\n */\n\n\nBone.prototype.matrix = function () {\n  if (this._matrix) return this._matrix;\n  var b = this.basis,\n      t = this._matrix = mat4.create(); // open transform mat4 from rotation mat3\n\n  t[0] = b[0][0], t[1] = b[0][1], t[2] = b[0][2];\n  t[4] = b[1][0], t[5] = b[1][1], t[6] = b[1][2];\n  t[8] = b[2][0], t[9] = b[2][1], t[10] = b[2][2];\n  t[3] = this.center()[0];\n  t[7] = this.center()[1];\n  t[11] = this.center()[2];\n\n  if (this.left()) {\n    // flip the basis to be right-handed\n    t[0] *= -1;\n    t[1] *= -1;\n    t[2] *= -1;\n  }\n\n  return this._matrix;\n};\n/**\r\n * Helper method to linearly interpolate between the two ends of the bone.\r\n *\r\n * when t = 0, the position of prevJoint will be returned\r\n * when t = 1, the position of nextJoint will be returned\r\n */\n\n\nBone.prototype.lerp = function (out, t) {\n  vec3.lerp(out, this.prevJoint, this.nextJoint, t);\n};\n/**\r\n *\r\n * The center position of the bone\r\n * Returns a vec3 array.\r\n *\r\n */\n\n\nBone.prototype.center = function () {\n  if (this._center) return this._center;\n  var center = vec3.create();\n  this.lerp(center, 0.5);\n  this._center = center;\n  return center;\n}; // The negative of the z-basis\n\n\nBone.prototype.direction = function () {\n  return [this.basis[2][0] * -1, this.basis[2][1] * -1, this.basis[2][2] * -1];\n};","map":null,"metadata":{},"sourceType":"script"}