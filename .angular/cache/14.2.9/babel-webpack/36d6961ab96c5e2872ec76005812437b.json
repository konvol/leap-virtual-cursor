{"ast":null,"code":"var Hand = require(\"./hand\"),\n    Pointable = require(\"./pointable\"),\n    glMatrix = require(\"gl-matrix\"),\n    mat3 = glMatrix.mat3,\n    vec3 = glMatrix.vec3,\n    InteractionBox = require(\"./interaction_box\"),\n    Finger = require('./finger');\n/**\r\n * Constructs a Frame object.\r\n *\r\n * Frame instances created with this constructor are invalid.\r\n * Get valid Frame objects by calling the\r\n * [Controller.frame]{@link Leap.Controller#frame}() function.\r\n *<C-D-Space>\r\n * @class Frame\r\n * @memberof Leap\r\n * @classdesc\r\n * The Frame class represents a set of hand and finger tracking data detected\r\n * in a single frame.\r\n *\r\n * The Leap detects hands, fingers within the tracking area, reporting\r\n * their positions, orientations and motions in frames at the Leap frame rate.\r\n *\r\n * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.\r\n */\n\n\nvar Frame = module.exports = function (data) {\n  /**\r\n   * Reports whether this Frame instance is valid.\r\n   *\r\n   * A valid Frame is one generated by the Controller object that contains\r\n   * tracking data for all detected entities. An invalid Frame contains no\r\n   * actual tracking data, but you can call its functions without risk of a\r\n   * undefined object exception. The invalid Frame mechanism makes it more\r\n   * convenient to track individual data across the frame history. For example,\r\n   * you can invoke:\r\n   *\r\n   * ```javascript\r\n   * var finger = controller.frame(n).finger(fingerID);\r\n   * ```\r\n   *\r\n   * for an arbitrary Frame history value, \"n\", without first checking whether\r\n   * frame(n) returned a null object. (You should still check that the\r\n   * returned Finger instance is valid.)\r\n   *\r\n   * @member valid\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {Boolean}\r\n   */\n  this.valid = true;\n  /**\r\n   * A unique ID for this Frame. Consecutive frames processed by the Leap\r\n   * have consecutive increasing values.\r\n   * @member id\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {String}\r\n   */\n\n  this.id = data.id;\n  /**\r\n   * The frame capture time in microseconds elapsed since the Leap started.\r\n   * @member timestamp\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {number}\r\n   */\n\n  this.timestamp = data.timestamp;\n  /**\r\n   * The list of Hand objects detected in this frame, given in arbitrary order.\r\n   * The list can be empty if no hands are detected.\r\n   *\r\n   * @member hands[]\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {Leap.Hand}\r\n   */\n\n  this.hands = [];\n  this.handsMap = {};\n  /**\r\n   * The list of Pointable objects (fingers) detected in this frame,\r\n   * given in arbitrary order. The list can be empty if no fingers are\r\n   * detected.\r\n   *\r\n   * @member pointables[]\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {Leap.Pointable}\r\n   */\n\n  this.pointables = [];\n  /**\r\n   * The list of Finger objects detected in this frame, given in arbitrary order.\r\n   * The list can be empty if no fingers are detected.\r\n   * @member fingers[]\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {Leap.Pointable}\r\n   */\n\n  this.fingers = [];\n  /**\r\n   * The InteractionBox associated with the current frame.\r\n   *\r\n   * @member interactionBox\r\n   * @memberof Leap.Frame.prototype\r\n   * @type {Leap.InteractionBox}\r\n   */\n\n  if (data.interactionBox) {\n    this.interactionBox = new InteractionBox(data.interactionBox);\n  }\n\n  this.pointablesMap = {};\n  this._translation = data.t;\n\n  function flattenDeep(arr) {\n    return Array.isArray(arr) ? arr.reduce(function (a, b) {\n      return a.concat(flattenDeep(b));\n    }, []) : [arr];\n  }\n\n  this._rotation = flattenDeep(data.r);\n  this._scaleFactor = data.s;\n  this.data = data;\n  this.type = 'frame'; // used by event emitting\n\n  this.currentFrameRate = data.currentFrameRate;\n  this.postprocessData(data);\n};\n\nFrame.prototype.postprocessData = function (data) {\n  if (!data) {\n    data = this.data;\n  }\n\n  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {\n    var hand = new Hand(data.hands[handIdx]);\n    hand.frame = this;\n    this.hands.push(hand);\n    this.handsMap[hand.id] = hand;\n  }\n\n  var sortBy = function (key) {\n    return function (a, b) {\n      return a[key] > b[key] ? 1 : b[key] > a[key] ? -1 : 0;\n    };\n  };\n\n  data.pointables.sort(sortBy(\"id\"));\n\n  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {\n    var pointableData = data.pointables[pointableIdx];\n    var pointable = pointableData.dipPosition ? new Finger(pointableData) : new Pointable(pointableData);\n    pointable.frame = this;\n    this.addPointable(pointable);\n  }\n};\n/**\r\n * Adds data from a pointable element into the pointablesMap; \r\n * also adds the pointable to the frame.handsMap hand to which it belongs,\r\n * and to the hand's fingers map.\r\n * \r\n * @param pointable {Object} a Pointable\r\n */\n\n\nFrame.prototype.addPointable = function (pointable) {\n  this.pointables.push(pointable);\n  this.pointablesMap[pointable.id] = pointable;\n  this.fingers.push(pointable);\n\n  if (pointable.handId !== undefined && this.handsMap.hasOwnProperty(pointable.handId)) {\n    var hand = this.handsMap[pointable.handId];\n    hand.pointables.push(pointable);\n    hand.fingers.push(pointable);\n\n    switch (pointable.type) {\n      case 0:\n        hand.thumb = pointable;\n        break;\n\n      case 1:\n        hand.indexFinger = pointable;\n        break;\n\n      case 2:\n        hand.middleFinger = pointable;\n        break;\n\n      case 3:\n        hand.ringFinger = pointable;\n        break;\n\n      case 4:\n        hand.pinky = pointable;\n        break;\n    }\n  }\n};\n/**\r\n * The Pointable object with the specified ID in this frame.\r\n *\r\n * Use the Frame pointable() function to retrieve the Pointable object from\r\n * this frame using an ID value obtained from a previous frame.\r\n * This function always returns a Pointable object, but if no finger\r\n * with the specified ID is present, an invalid Pointable object is returned.\r\n *\r\n * Note that ID values persist across frames, but only until tracking of a\r\n * particular object is lost. If tracking of a finger is lost and subsequently\r\n * regained, the new Pointable object representing that finger may have\r\n * a different ID than that representing the finger in an earlier frame.\r\n *\r\n * @method pointable\r\n * @memberof Leap.Frame.prototype\r\n * @param {String} id The ID value of a Pointable object from a previous frame.\r\n * @returns {Leap.Pointable} The Pointable object with\r\n * the matching ID if one exists in this frame;\r\n * otherwise, an invalid Pointable object is returned.\r\n */\n\n\nFrame.prototype.pointable = function (id) {\n  return this.pointablesMap[id] || Pointable.Invalid;\n};\n/**\r\n * The finger with the specified ID in this frame.\r\n *\r\n * Use the Frame finger() function to retrieve the finger from\r\n * this frame using an ID value obtained from a previous frame.\r\n * This function always returns a Finger object, but if no finger\r\n * with the specified ID is present, an invalid Pointable object is returned.\r\n *\r\n * Note that ID values persist across frames, but only until tracking of a\r\n * particular object is lost. If tracking of a finger is lost and subsequently\r\n * regained, the new Pointable object representing that physical finger may have\r\n * a different ID than that representing the finger in an earlier frame.\r\n *\r\n * @method finger\r\n * @memberof Leap.Frame.prototype\r\n * @param {String} id The ID value of a finger from a previous frame.\r\n * @returns {Leap.Pointable} The finger with the\r\n * matching ID if one exists in this frame; otherwise, an invalid Pointable\r\n * object is returned.\r\n */\n\n\nFrame.prototype.finger = function (id) {\n  return this.pointable(id);\n};\n/**\r\n * The Hand object with the specified ID in this frame.\r\n *\r\n * Use the Frame hand() function to retrieve the Hand object from\r\n * this frame using an ID value obtained from a previous frame.\r\n * This function always returns a Hand object, but if no hand\r\n * with the specified ID is present, an invalid Hand object is returned.\r\n *\r\n * Note that ID values persist across frames, but only until tracking of a\r\n * particular object is lost. If tracking of a hand is lost and subsequently\r\n * regained, the new Hand object representing that physical hand may have\r\n * a different ID than that representing the physical hand in an earlier frame.\r\n *\r\n * @method hand\r\n * @memberof Leap.Frame.prototype\r\n * @param {String} id The ID value of a Hand object from a previous frame.\r\n * @returns {Leap.Hand} The Hand object with the matching\r\n * ID if one exists in this frame; otherwise, an invalid Hand object is returned.\r\n */\n\n\nFrame.prototype.hand = function (id) {\n  return this.handsMap[id] || Hand.Invalid;\n};\n/**\r\n * The angle of rotation around the rotation axis derived from the overall\r\n * rotational motion between the current frame and the specified frame.\r\n *\r\n * The returned angle is expressed in radians measured clockwise around\r\n * the rotation axis (using the right-hand rule) between the start and end frames.\r\n * The value is always between 0 and pi radians (0 and 180 degrees).\r\n *\r\n * The Leap derives frame rotation from the relative change in position and\r\n * orientation of all objects detected in the field of view.\r\n *\r\n * If either this frame or sinceFrame is an invalid Frame object, then the\r\n * angle of rotation is zero.\r\n *\r\n * @method rotationAngle\r\n * @memberof Leap.Frame.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\r\n * @param {number[]} [axis] The axis to measure rotation around.\r\n * @returns {number} A positive value containing the heuristically determined\r\n * rotational change between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nFrame.prototype.rotationAngle = function (sinceFrame, axis) {\n  if (!this.valid || !sinceFrame.valid) return 0.0;\n  var rot = this.rotationMatrix(sinceFrame);\n  var cs = (rot[0] + rot[4] + rot[8] - 1.0) * 0.5;\n  var angle = Math.acos(cs);\n  angle = isNaN(angle) ? 0.0 : angle;\n\n  if (axis !== undefined) {\n    var rotAxis = this.rotationAxis(sinceFrame);\n    angle *= vec3.dot(rotAxis, vec3.normalize(vec3.create(), axis));\n  }\n\n  return angle;\n};\n/**\r\n * The axis of rotation derived from the overall rotational motion between\r\n * the current frame and the specified frame.\r\n *\r\n * The returned direction vector is normalized.\r\n *\r\n * The Leap derives frame rotation from the relative change in position and\r\n * orientation of all objects detected in the field of view.\r\n *\r\n * If either this frame or sinceFrame is an invalid Frame object, or if no\r\n * rotation is detected between the two frames, a zero vector is returned.\r\n *\r\n * @method rotationAxis\r\n * @memberof Leap.Frame.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\r\n * @returns {number[]} A normalized direction vector representing the axis of the heuristically determined\r\n * rotational change between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nFrame.prototype.rotationAxis = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  return vec3.normalize(vec3.create(), [this._rotation[7] - sinceFrame._rotation[5], this._rotation[2] - sinceFrame._rotation[6], this._rotation[3] - sinceFrame._rotation[1]]);\n};\n/**\r\n * The transform matrix expressing the rotation derived from the overall\r\n * rotational motion between the current frame and the specified frame.\r\n *\r\n * The Leap derives frame rotation from the relative change in position and\r\n * orientation of all objects detected in the field of view.\r\n *\r\n * If either this frame or sinceFrame is an invalid Frame object, then\r\n * this method returns an identity matrix.\r\n *\r\n * @method rotationMatrix\r\n * @memberof Leap.Frame.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.\r\n * @returns {number[]} A transformation matrix containing the heuristically determined\r\n * rotational change between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nFrame.prototype.rotationMatrix = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return mat3.create();\n  var transpose = mat3.transpose(mat3.create(), this._rotation);\n  return mat3.multiply(mat3.create(), sinceFrame._rotation, transpose);\n};\n/**\r\n * The scale factor derived from the overall motion between the current frame and the specified frame.\r\n *\r\n * The scale factor is always positive. A value of 1.0 indicates no scaling took place.\r\n * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.\r\n *\r\n * The Leap derives scaling from the relative inward or outward motion of all\r\n * objects detected in the field of view (independent of translation and rotation).\r\n *\r\n * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.\r\n *\r\n * @method scaleFactor\r\n * @memberof Leap.Frame.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.\r\n * @returns {number} A positive value representing the heuristically determined\r\n * scaling change ratio between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nFrame.prototype.scaleFactor = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return 1.0;\n  return Math.exp(this._scaleFactor - sinceFrame._scaleFactor);\n};\n/**\r\n * The change of position derived from the overall linear motion between the\r\n * current frame and the specified frame.\r\n *\r\n * The returned translation vector provides the magnitude and direction of the\r\n * movement in millimeters.\r\n *\r\n * The Leap derives frame translation from the linear motion of all objects\r\n * detected in the field of view.\r\n *\r\n * If either this frame or sinceFrame is an invalid Frame object, then this\r\n * method returns a zero vector.\r\n *\r\n * @method translation\r\n * @memberof Leap.Frame.prototype\r\n * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.\r\n * @returns {number[]} A vector representing the heuristically determined change in\r\n * position of all objects between the current frame and that specified in the sinceFrame parameter.\r\n */\n\n\nFrame.prototype.translation = function (sinceFrame) {\n  if (!this.valid || !sinceFrame.valid) return vec3.create();\n  return vec3.subtract(vec3.create(), this._translation, sinceFrame._translation);\n};\n/**\r\n * A string containing a brief, human readable description of the Frame object.\r\n *\r\n * @method toString\r\n * @memberof Leap.Frame.prototype\r\n * @returns {String} A brief description of this frame.\r\n */\n\n\nFrame.prototype.toString = function () {\n  var str = \"Frame [ id:\" + this.id + \" | timestamp:\" + this.timestamp + \" | Hand count:(\" + this.hands.length + \") | Pointable count:(\" + this.pointables.length + \")\";\n  str += \" ]\";\n  return str;\n};\n/**\r\n * Returns a JSON-formatted string containing the hands, pointables\r\n * in this frame.\r\n *\r\n * @method dump\r\n * @memberof Leap.Frame.prototype\r\n * @returns {String} A JSON-formatted string.\r\n */\n\n\nFrame.prototype.dump = function () {\n  var out = '';\n  out += \"Frame Info:<br/>\";\n  out += this.toString();\n  out += \"<br/><br/>Hands:<br/>\";\n\n  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {\n    out += \"  \" + this.hands[handIdx].toString() + \"<br/>\";\n  }\n\n  out += \"<br/><br/>Pointables:<br/>\";\n\n  for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {\n    out += \"  \" + this.pointables[pointableIdx].toString() + \"<br/>\";\n  }\n\n  out += \"<br/><br/>Raw JSON:<br/>\";\n  out += JSON.stringify(this.data);\n  return out;\n};\n/**\r\n * An invalid Frame object.\r\n *\r\n * You can use this invalid Frame in comparisons testing\r\n * whether a given Frame instance is valid or invalid. (You can also check the\r\n * [Frame.valid]{@link Leap.Frame#valid} property.)\r\n *\r\n * @static\r\n * @type {Leap.Frame}\r\n * @name Invalid\r\n * @memberof Leap.Frame\r\n */\n\n\nFrame.Invalid = {\n  valid: false,\n  hands: [],\n  fingers: [],\n  pointables: [],\n  pointable: function () {\n    return Pointable.Invalid;\n  },\n  finger: function () {\n    return Pointable.Invalid;\n  },\n  hand: function () {\n    return Hand.Invalid;\n  },\n  toString: function () {\n    return \"invalid frame\";\n  },\n  dump: function () {\n    return this.toString();\n  },\n  rotationAngle: function () {\n    return 0.0;\n  },\n  rotationMatrix: function () {\n    return mat3.create();\n  },\n  rotationAxis: function () {\n    return vec3.create();\n  },\n  scaleFactor: function () {\n    return 1.0;\n  },\n  translation: function () {\n    return vec3.create();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}