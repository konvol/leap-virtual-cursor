{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport * as Leap from 'leapjs';\nimport * as i0 from \"@angular/core\";\n/***********************************************/\n\nexport var Gestures = /*#__PURE__*/(() => {\n  (function (Gestures) {\n    Gestures[Gestures[\"SWIPE_LEFT\"] = 0] = \"SWIPE_LEFT\";\n    Gestures[Gestures[\"SWIPE_UP\"] = 1] = \"SWIPE_UP\";\n    Gestures[Gestures[\"SWIPE_DOWN\"] = 2] = \"SWIPE_DOWN\";\n    Gestures[Gestures[\"SWIPE_RIGHT\"] = 3] = \"SWIPE_RIGHT\";\n    Gestures[Gestures[\"CIRCLE_CLOCKWISE\"] = 4] = \"CIRCLE_CLOCKWISE\";\n    Gestures[Gestures[\"CIRCLE_COUNTERCLOCKWISE\"] = 5] = \"CIRCLE_COUNTERCLOCKWISE\";\n    Gestures[Gestures[\"PINCH\"] = 6] = \"PINCH\";\n  })(Gestures || (Gestures = {}));\n\n  return Gestures;\n})();\n\n/***********************************************/\nexport let LeapService = /*#__PURE__*/(() => {\n  class LeapService {\n    /*****************************/\n    constructor() {\n      this.GesturesStr = [\"SWIPE_LEFT\", \"SWIPE_UP\", \"SWIPE_DOWN\", \"SWIPE_RIGHT\", \"CIRCLE_CLOCKWISE\", \"CIRCLE_COUNTERCLOCKWISE\", \"PINCH\"];\n      /*****************************/\n\n      this.timeoutAfterRecognition = 3000; //ms change according to how much time you need to wait from one gesture to the next\n\n      this.framesForGesture = 3;\n      /*****************************/\n\n      this.gestureCounter = 0;\n      var controllerOptions = {\n        enableGestures: true\n      };\n      this.gestureRecognized = null;\n      this.initializeEmmiters();\n      Leap.loop(controllerOptions, frame => {\n        let cursor = this.leapLoop(frame);\n        var gesture = this.findGesture(frame);\n        if (gesture != null) this.gestureEvent.emit(gesture);\n        if (cursor) this.positionEvent.emit(cursor);\n      });\n    }\n    /*****************************/\n\n\n    cursorRecognizer() {\n      return this.positionEvent;\n    }\n\n    gestureRecognizer() {\n      return this.gestureEvent;\n    }\n    /*****************************/\n\n\n    leapLoop(frame) {\n      if (frame.pointables && frame.pointables.length == 0) return null; // Currently using palm as cursor. Use pointables[0].tipPosition if you want to use your index finger as cursor\n\n      var normalizedPosition = frame.interactionBox.normalizePoint(frame.hands[0].palmPosition, true);\n      if (normalizedPosition[2] < 0.2 || normalizedPosition[2] > 0.8) return null;\n      this.findPinch(frame);\n      return {\n        xPos: Math.trunc(normalizedPosition[0] * window.innerWidth),\n        yPos: Math.trunc(window.innerHeight - normalizedPosition[1] * window.innerHeight)\n      };\n    }\n    /**\r\n     * This function can be edited in order to implement more advanced gesture handling features\r\n     *\r\n     */\n\n\n    findGesture(frame) {\n      var gesture = this.getGesture(frame);\n\n      if (!gesture) {\n        this.currGesture = null;\n        return null;\n      }\n\n      var foundGesture = null;\n\n      switch (gesture.type) {\n        case 'swipe':\n          foundGesture = this.swipeHander(gesture);\n          break;\n\n        case 'circle':\n          foundGesture = this.circleHander(frame, gesture);\n          break;\n\n        default:\n          // you can add more basic gestures here\n          return null;\n      }\n\n      this.gestureRecognized = this.GesturesStr[foundGesture];\n      return this.checkAndReturnGesture(foundGesture);\n    }\n    /*****************************/\n    // implemented in different function than the rest of gestures, because it is not regarded as gesture for leap\n\n\n    findPinch(frame) {\n      if (frame.data.hands[0].pinchStrength === 1) {\n        //depends on the accuracy you want. Max and more accurate is 1!\n        this.gestureRecognized = this.GesturesStr[Gestures.PINCH];\n      }\n    }\n    /*****************************/\n\n\n    checkAndReturnGesture(foundGesture) {\n      if (this.gestureCounter == -1) return;\n\n      if (this.currGesture == foundGesture) {\n        this.gestureCounter++;\n      } else {\n        this.currGesture = foundGesture;\n        this.gestureCounter = 0;\n      }\n\n      if (this.gestureCounter == this.framesForGesture) {\n        this.resetGestures();\n        return foundGesture;\n      }\n\n      return null;\n    }\n    /*****************************/\n\n\n    resetGestures() {\n      this.currGesture = null;\n      this.gestureCounter = -1;\n      setTimeout(() => {\n        this.gestureCounter = 0;\n      }, this.timeoutAfterRecognition);\n    }\n    /*****************************/\n\n\n    getGesture(frame) {\n      if (!frame.valid || frame.data.gestures.length == 0) return null;\n      var gestures = frame.data.gestures;\n      var gesture = gestures[0];\n      if (!gesture) return null;\n      return gesture;\n    }\n    /*****************************/\n\n\n    swipeHander(gesture) {\n      if (Math.abs(gesture.direction[0]) > Math.abs(gesture.direction[1])) {\n        // swipe gestures recognize hand direction\n        if (gesture.direction[0] > 0) return Gestures.SWIPE_RIGHT;\n        return Gestures.SWIPE_LEFT;\n      }\n\n      if (gesture.direction[1] > 0) return Gestures.SWIPE_UP;\n      return Gestures.SWIPE_DOWN;\n    }\n    /*****************************/\n\n\n    circleHander(frame, gesture) {\n      if (!gesture || !gesture.pointableIds) return null;\n      var pointableID = gesture.pointableIds[0]; // circle gestures recognize finger movement\n\n      var direction = frame.pointable(pointableID).direction;\n      var dotProduct = Leap.vec3.dot(direction, gesture.normal);\n      if (dotProduct > 0) return Gestures.CIRCLE_CLOCKWISE;\n      return Gestures.CIRCLE_COUNTERCLOCKWISE;\n    }\n    /*****************************/\n    //#region Initializing\n\n\n    initializeEmmiters() {\n      this.positionEvent = new EventEmitter();\n      this.gestureEvent = new EventEmitter();\n    }\n\n  }\n\n  LeapService.ɵfac = function LeapService_Factory(t) {\n    return new (t || LeapService)();\n  };\n\n  LeapService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LeapService,\n    factory: LeapService.ɵfac,\n    providedIn: 'root'\n  });\n  return LeapService;\n})();","map":null,"metadata":{},"sourceType":"module"}